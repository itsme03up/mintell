"use client";

import { useState, useEffect } from "react";
import FullCalendar from "@fullcalendar/react";
import dayGridPlugin from "@fullcalendar/daygrid";
import interactionPlugin from "@fullcalendar/interaction";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogHeader, DialogFooter } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectItem, SelectContent, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { Member } from "@/lib/types";

interface Event {
  id: string;
  title: string;
  start: string;
  end?: string;
  description?: string;
  location?: string;
  maxParticipants?: number;
  partyId?: number;
}

interface Party {
  id: string;
  name: string;
  members?: number[];
}

interface Participant {
  userId: string;
  username: string;
  status: 'attending' | 'not-attending' | 'maybe';
}

interface DiscordSettings {
  webhookUrl: string;
  botToken: string; // Consider security implications if this remains client-side
  channelId?: string;
}

export default function EventsPage() {
  const [events, setEvents] = useState<Event[]>([]);
  const [showModal, setShowModal] = useState(false);
  const [newEventTitle, setNewEventTitle] = useState("");
  const [newEventDate, setNewEventDate] = useState("");
  const [newEventEndDate, setNewEventEndDate] = useState("");
  const [newEventDescription, setNewEventDescription] = useState("");
  const [newEventLocation, setNewEventLocation] = useState("");
  const [newEventMaxParticipants, setNewEventMaxParticipants] = useState<number | undefined>(undefined);
  const [selectedPartyId, setSelectedPartyId] = useState<string | undefined>(undefined);
  const [characters, setCharacters] = useState<Member[]>([]);
  const [availableMembers, setAvailableMembers] = useState<Member[]>([]);
  const [eventMembers, setEventMembers] = useState<Member[]>([]);
  const [parties, setParties] = useState<Party[]>([]);
  
  // DiscordÈñ¢ÈÄ£„ÅÆstate
  const [discordSettings, setDiscordSettings] = useState<DiscordSettings>({
    webhookUrl: process.env.NEXT_PUBLIC_DISCORD_WEBHOOK_URL || '',
    botToken: process.env.NEXT_PUBLIC_DISCORD_BOT_TOKEN || '', // WARNING: Exposing bot token client-side is risky
    channelId: process.env.NEXT_PUBLIC_DISCORD_CHANNEL_ID || ''
  });
  const [participants, setParticipants] = useState<Map<string, Participant[]>>(new Map());
  // const [showDiscordSettings, setShowDiscordSettings] = useState(false); // Removed
  const [isCreatingEvent, setIsCreatingEvent] = useState(false);

  // „Éê„É™„Éá„Éº„Ç∑„Éß„É≥Èñ¢Êï∞
  const isValidWebhookUrl = (url: string): boolean => {
    const webhookPattern = /^https:\/\/discord\.com\/api\/webhooks\/\d+\/[\w-]+$/;
    return webhookPattern.test(url);
  };

  const initParties = async () => {
    const response = await fetch('/api/partybuilder');
    if (!response.ok) {
      throw new Error('Failed to fetch members data');
    }

    const data = await response.json();

    setParties(data);
  }

  const initMembers = async () => {
    try {
      const response = await fetch('/api/members');
      if (!response.ok) {
        throw new Error('Failed to fetch members data');
      }

      const membersData: Member[] = await response.json();

      setCharacters(membersData);
      setAvailableMembers(membersData);
    } catch (error) {
      console.error('Error fetching members:', error);
      alert('„É°„É≥„Éê„Éº„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ');
    }
  }

  useEffect(() => {
    initParties();
    initMembers();
    // loadDiscordSettings(); // Removed: Settings now come from .env
  }, []);

  // DiscordË®≠ÂÆö„ÇíË™≠„ÅøËæº„Åø // Removed
  // const loadDiscordSettings = () => { ... };

  // DiscordË®≠ÂÆö„Çí‰øùÂ≠ò // Removed
  // const saveDiscordSettings = (settings: DiscordSettings) => { ... };

  const resetNewEventForm = () => {
    setNewEventTitle("");
    setNewEventDate("");
    setNewEventEndDate("");
    setNewEventDescription("");
    setNewEventLocation("");
    setNewEventMaxParticipants(undefined);
    setSelectedPartyId(undefined);
    setEventMembers([]); // Reset event members
    setAvailableMembers(characters); // Reset available members
  };

  const handleDateClick = (info: { dateStr: string }) => {
    setNewEventDate(info.dateStr);
    setShowModal(true);
  };

  const handleAddEvent = async () => {
    if (!newEventTitle || !newEventDate) return;

    // Check if essential Discord settings are available from .env
    if (!discordSettings.webhookUrl) {
      alert("Discord Webhook URL„ÅåÁí∞Â¢ÉÂ§âÊï∞„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÈÄöÁü•„ÅØÈÄÅ‰ø°„Åß„Åç„Åæ„Åõ„Çì„ÄÇ");
      // Optionally, you might want to prevent event creation or proceed without Discord functionality
    }
    // Add a similar check for botToken if addDiscordReactions is critical and stays client-side
    // if (!discordSettings.botToken) {
    //   alert("Discord Bot Token„ÅåÁí∞Â¢ÉÂ§âÊï∞„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØËøΩÂä†„Åß„Åç„Åæ„Åõ„Çì„ÄÇ");
    // }


    setIsCreatingEvent(true);

    try {
      const startDate = new Date(newEventDate);
      const endDate = newEventEndDate ? new Date(newEventEndDate) : new Date(startDate.getTime() + 2 * 60 * 60 * 1000);

      const newEvent: Event = {
        id: Date.now().toString(),
        title: newEventTitle,
        start: newEventDate,
        end: newEventEndDate || undefined,
        description: newEventDescription || undefined,
        location: newEventLocation || undefined,
        maxParticipants: newEventMaxParticipants || undefined,
        partyId: selectedPartyId ? parseInt(selectedPartyId, 10) : undefined,
      };

      setEvents((prev) => [...prev, newEvent]);

      // DiscordÈÄöÁü•„ÇíÈÄÅ‰ø°
      const sendDiscordNotification = async (event: Event, startDate: Date, endDate: Date): Promise<string | null> => {
        const embed = {
          title: "üìÖ " + event.title,
          description: event.description || "Êñ∞„Åó„ÅÑ„Ç§„Éô„É≥„Éà„Åå‰ΩúÊàê„Åï„Çå„Åæ„Åó„ÅüÔºÅ",
          color: 0x4285f4,
          fields: [
            {
              name: "üïê ÈñãÂßãÊôÇÈñì",
              value: startDate.toLocaleString('ja-JP', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                weekday: 'short'
              }),
              inline: true
            },
            {
              name: "üïê ÁµÇ‰∫ÜÊôÇÈñì", 
              value: endDate.toLocaleString('ja-JP', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                weekday: 'short'
              }),
              inline: true
            }
          ],
          footer: {
            text: "‰∏ã„ÅÆ„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅßÂèÇÂä†ÂèØÂê¶„Çí„ÅäÁü•„Çâ„Åõ„Åè„Å†„Åï„ÅÑÔºÅ"
          },
          timestamp: new Date().toISOString()
        };

        if (event.location) {
          embed.fields.push({
            name: "üìç Â†¥ÊâÄ",
            value: event.location,
            inline: true
          });
        }

        if (event.maxParticipants) {
          embed.fields.push({
            name: "üë• ÊúÄÂ§ßÂèÇÂä†ËÄÖÊï∞",
            value: event.maxParticipants + "Âêç",
            inline: true
          });
        }

        // ÂèÇÂä†„É°„É≥„Éê„Éº„Åå„ÅÑ„ÇãÂ†¥Âêà
        if (eventMembers.length > 0) {
          embed.fields.push({
            name: "üë®‚Äçüë©‚Äçüëß‚Äçüë¶ ÂèÇÂä†‰∫àÂÆö„É°„É≥„Éê„Éº",
            value: eventMembers.map(m => m.fullName).join(", "),
            inline: false
          });
        }

        const payload = {
          content: "üéâ **Êñ∞„Åó„ÅÑ„Ç§„Éô„É≥„Éà„ÅÆ„ÅäÁü•„Çâ„Åõ** üéâ",
          embeds: [embed],
          wait: true
        };

        try {
          const response = await fetch(discordSettings.webhookUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            throw new Error(`Discord API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          return result.id;
        } catch (error) {
          console.error('Error sending Discord notification:', error);
          throw error;
        }
      };

      const addDiscordReactions = async (messageId: string): Promise<void> => {
        const reactions = ['‚úÖ', '‚ùå', '‚ùì'];
        // Use NEXT_PUBLIC_DISCORD_CHANNEL_ID for targetChannelId if available, otherwise try to extract (though extraction is unreliable)
        const targetChannelId = discordSettings.channelId || extractChannelIdFromWebhook(discordSettings.webhookUrl);
        
        if (!discordSettings.botToken) {
          console.warn('Bot Token is not configured. Skipping adding reactions.');
          alert('Bot Token„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åü„ÇÅ„ÄÅ„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØËøΩÂä†„Åï„Çå„Åæ„Åõ„Çì„ÄÇ');
          return;
        }
        
        if (!targetChannelId) {
          console.warn('Channel ID not available for adding reactions');
          return;
        }

        for (const reaction of reactions) {
          try {
            const response = await fetch(`https://discord.com/api/v10/channels/${targetChannelId}/messages/${messageId}/reactions/${encodeURIComponent(reaction)}/@me`, {
              method: 'PUT',
              headers: {
                'Authorization': `Bot ${discordSettings.botToken}`,
                'Content-Type': 'application/json'
              }
            });

            if (!response.ok) {
              console.error(`Failed to add reaction ${reaction}:`, response.status, response.statusText);
            }
            
            // API„É¨„Éº„ÉàÂà∂Èôê„ÇíÈÅø„Åë„Çã„Åü„ÇÅÂ∞ë„ÅóÂæÖÊ©ü
            await new Promise(resolve => setTimeout(resolve, 500));
          } catch (error) {
            console.error(`Error adding reaction ${reaction}:`, error);
          }
        }
      };

      // WebhookURL„Åã„Çâ„ÉÅ„É£„É≥„Éç„É´ID„ÇíÊäΩÂá∫ÔºàÂà∂Èôê„ÅÇ„ÇäÔºâ
      const extractChannelIdFromWebhook = (webhookUrl: string): string | null => {
        // Webhook URL„Åã„ÇâÁõ¥Êé•„ÉÅ„É£„É≥„Éç„É´ID„ÇíÂèñÂæó„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Å™„ÅÑ„Åü„ÇÅ„ÄÅ
        // „É¶„Éº„Ç∂„Éº„Å´„ÉÅ„É£„É≥„Éç„É´ID„ÅÆÂÖ•Âäõ„Çí‰øÉ„ÅôÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô
        return null;
      };

      const messageId = await sendDiscordNotification(newEvent, startDate, endDate);
      if (messageId) {
        await addDiscordReactions(messageId);
        // ÂèÇÂä†ËÄÖÁõ£Ë¶ñ„ÇíÈñãÂßãÔºàÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØÈÅ©Âàá„Å™„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆöÔºâ
        console.log(`Discord notification sent for event: ${newEvent.title}`);
      }

      setShowModal(false);

      // Google„Ç´„É¨„É≥„ÉÄ„ÉºÈÄ£Êê∫
      const formatGCalDate = (date: Date) =>
        date.toISOString().replace(/[-:.]/g, "").split(".")[0] + "Z";

      const gcalUrl = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(newEventTitle)}&dates=${formatGCalDate(startDate)}/${formatGCalDate(endDate)}&details=${encodeURIComponent("ÂèÇÂä†„É°„É≥„Éê„ÉºÔºö" + eventMembers.map(m => m.fullName).join(", "))}`;

      window.open(gcalUrl, "_blank");
      resetNewEventForm();
    } catch (error) {
      console.error('Error creating event:', error);
      alert('„Ç§„Éô„É≥„Éà„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ');
    } finally {
      setIsCreatingEvent(false);
    }
  };

  const handleDeleteEvent = (eventId: string) => {
    setEvents((prevEvents) => prevEvents.filter(event => event.id !== eventId));
  };

  const handleDragStart = (e: React.DragEvent, memberId: number) => {
    e.dataTransfer.setData("memberId", memberId.toString());
  };

  const handleDrop = (e: React.DragEvent, target: "available" | "event") => {
    e.preventDefault();
    const memberId = parseInt(e.dataTransfer.getData("memberId"), 10);
    if (isNaN(memberId)) return;

    if (target === "event") {
      const member = availableMembers.find((m) => m.id === memberId);
      if (member) {
        setEventMembers((prev) => [...prev, member]);
        setAvailableMembers((prev) => prev.filter((m) => m.id !== memberId));
      }
    } else if (target === "available") {
      const member = eventMembers.find((m) => m.id === memberId);
      if (member) {
        setAvailableMembers((prev) => [...prev, member]);
        setEventMembers((prev) => prev.filter((m) => m.id !== memberId));
      }
    }
  };

  const handleDragOver = (e: React.DragEvent) => e.preventDefault();

  const handlePartySelect = (partyIdStr: string) => {
    setSelectedPartyId(partyIdStr);

    const party = parties.find((p) => p.id === partyIdStr);
    if (party) {
      const membersInParty = characters.filter((c) => party.members?.includes(c.id));
      const remainingAvailable = characters.filter((c) => !party.members?.includes(c.id));
      setEventMembers(membersInParty);
      setAvailableMembers(remainingAvailable);
    } else {
      // If partyIdStr is undefined or party not found, reset members
      setEventMembers([]);
      setAvailableMembers(characters);
    }
  };

  return (
    <div className="container mx-auto py-6">
      <div className="flex justify-between items-center mb-4">
        <h1 className="text-3xl font-bold">Mintell „Ç§„Éô„É≥„ÉàÁÆ°ÁêÜ</h1>
        {/* Button to open Discord settings dialog removed */}
      </div>
      
      <Card className="p-4">
        <FullCalendar
          plugins={[dayGridPlugin, interactionPlugin]}
          initialView="dayGridMonth"
          events={events}
          dateClick={handleDateClick}
          eventContent={(eventInfo) => (
            <div className="flex items-center justify-between w-full">
              <span className="truncate" title={eventInfo.event.title}>{eventInfo.event.title}</span>
              <Button
                variant="ghost"
                size="sm"
                className="ml-2 p-1 h-auto text-xs text-red-500 hover:bg-red-100"
                onClick={(e) => {
                  e.stopPropagation(); // Prevent eventClick if we were using it
                  handleDeleteEvent(eventInfo.event.id);
                }}
              >
                ÂâäÈô§
              </Button>
            </div>
          )}
        />
      </Card>

      <Dialog open={showModal} onOpenChange={(isOpen) => {
        setShowModal(isOpen);
        if (!isOpen) {
          resetNewEventForm(); // Reset form fields when dialog is closed
        }
      }}>
        <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
          <DialogHeader>Êñ∞Ë¶è„Ç§„Éô„É≥„Éà‰ΩúÊàê</DialogHeader>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Â∑¶ÂÅ¥: „Ç§„Éô„É≥„ÉàÂü∫Êú¨ÊÉÖÂ†± */}
            <div className="space-y-4">
              <div>
                <Label>„Çø„Ç§„Éà„É´ *</Label>
                <Input 
                  value={newEventTitle} 
                  onChange={(e) => setNewEventTitle(e.target.value)} 
                  placeholder="‰æã: „ÉÅ„Éº„É†ÂÆö‰æã„Éü„Éº„ÉÜ„Ç£„É≥„Ç∞"
                />
              </div>
              
              <div>
                <Label>Ë™¨Êòé</Label>
                <Textarea 
                  value={newEventDescription} 
                  onChange={(e) => setNewEventDescription(e.target.value)}
                  placeholder="„Ç§„Éô„É≥„Éà„ÅÆË©≥Á¥∞„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ..."
                  rows={3}
                />
              </div>

              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label>ÈñãÂßãÊó•ÊôÇ *</Label>
                  <Input 
                    type="datetime-local" 
                    value={newEventDate} 
                    onChange={(e) => setNewEventDate(e.target.value)} 
                  />
                </div>
                <div>
                  <Label>ÁµÇ‰∫ÜÊó•ÊôÇ</Label>
                  <Input 
                    type="datetime-local" 
                    value={newEventEndDate} 
                    onChange={(e) => setNewEventEndDate(e.target.value)} 
                  />
                </div>
              </div>

              <div>
                <Label>Â†¥ÊâÄ</Label>
                <Input 
                  value={newEventLocation} 
                  onChange={(e) => setNewEventLocation(e.target.value)}
                  placeholder="‰æã: ‰ºöË≠∞ÂÆ§A, „Ç™„É≥„É©„Ç§„É≥, etc..."
                />
              </div>

              <div>
                <Label>ÊúÄÂ§ßÂèÇÂä†ËÄÖÊï∞</Label>
                <Input 
                  type="number" 
                  min="1"
                  value={newEventMaxParticipants || ''} 
                  onChange={(e) => setNewEventMaxParticipants(e.target.value ? parseInt(e.target.value) : undefined)}
                  placeholder="Âà∂Èôê„Å™„Åó„ÅÆÂ†¥Âêà„ÅØÁ©∫ÁôΩ"
                />
              </div>

              <div>
                <Label>„Éë„Éº„ÉÜ„Ç£ÈÅ∏Êäû</Label>
                <Select value={selectedPartyId} onValueChange={handlePartySelect}>
                  <SelectTrigger><SelectValue placeholder="ÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ" /></SelectTrigger>
                  <SelectContent>
                    {parties.map((p) => (
                      <SelectItem key={p.id} value={p.id.toString()}>{p.name}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              {/* DiscordË®≠ÂÆöÁä∂Ê≥Å */}
              <div className="p-3 bg-gray-50 rounded-lg">
                <div className="text-sm font-medium mb-2">DiscordÈÄöÁü•Ë®≠ÂÆö (Áí∞Â¢ÉÂ§âÊï∞„Åã„ÇâË™≠Ëæº)</div>
                <div className="text-xs text-gray-600">
                  {discordSettings.webhookUrl ? (
                    <span className="text-green-600">‚úÖ Webhook URL: Ë®≠ÂÆöÊ∏à„Åø</span>
                  ) : (
                    <span className="text-orange-600">‚ö†Ô∏è Webhook URL: Êú™Ë®≠ÂÆö (NEXT_PUBLIC_DISCORD_WEBHOOK_URL)</span>
                  )}
                </div>
                <div className="text-xs text-gray-600 mt-1">
                  {discordSettings.botToken ? (
                    <span className="text-green-600">‚úÖ Bot Token: Ë®≠ÂÆöÊ∏à„Åø („Çª„Ç≠„É•„É™„ÉÜ„Ç£Ê≥®ÊÑè)</span>
                  ) : (
                    <span className="text-orange-600">‚ö†Ô∏è Bot Token: Êú™Ë®≠ÂÆö (NEXT_PUBLIC_DISCORD_BOT_TOKEN)</span>
                  )}
                </div>
                 <div className="text-xs text-gray-600 mt-1">
                  {discordSettings.channelId ? (
                    <span className="text-green-600">‚úÖ Channel ID: Ë®≠ÂÆöÊ∏à„Åø</span>
                  ) : (
                    <span className="text-gray-500">‚ÑπÔ∏è Channel ID: Êú™Ë®≠ÂÆö (NEXT_PUBLIC_DISCORD_CHANNEL_ID)</span>
                  )}
                </div>
              </div>
            </div>

            {/* Âè≥ÂÅ¥: „É°„É≥„Éê„ÉºÈÅ∏Êäû */}
            <div>
              <div className="grid grid-cols-2 gap-4 h-full">
                <div
                  onDrop={(e) => handleDrop(e, "available")}
                  onDragOver={handleDragOver}
                  className="border p-2 rounded bg-gray-50 min-h-[200px]"
                >
                  <h3 className="font-semibold mb-2">ÂÖ®„É°„É≥„Éê„Éº</h3>
                  <div className="max-h-40 overflow-y-auto">
                    {availableMembers.map((m) => (
                      <div
                        key={m.id}
                        draggable
                        onDragStart={(e) => handleDragStart(e, m.id)}
                        className="p-1 border rounded my-1 bg-white cursor-move text-sm"
                      >
                        {m.fullName}
                      </div>
                    ))}
                  </div>
                </div>

                <div
                  onDrop={(e) => handleDrop(e, "event")}
                  onDragOver={handleDragOver}
                  className="border p-2 rounded bg-green-50 min-h-[200px]"
                >
                  <h3 className="font-semibold mb-2">„Ç§„Éô„É≥„ÉàÂèÇÂä†ËÄÖ</h3>
                  <div className="max-h-40 overflow-y-auto">
                    {eventMembers.map((m) => (
                      <div
                        key={m.id}
                        draggable
                        onDragStart={(e) => handleDragStart(e, m.id)}
                        className="p-1 border rounded my-1 bg-green-100 cursor-move text-sm"
                      >
                        {m.fullName}
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <DialogFooter>
            <Button variant="outline" onClick={() => {
              setShowModal(false);
              resetNewEventForm();
            }}>
              „Ç≠„É£„É≥„Çª„É´
            </Button>
            <Button 
              onClick={handleAddEvent} 
              disabled={isCreatingEvent}
              className="flex items-center gap-2"
            >
              {isCreatingEvent ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                  ‰ΩúÊàê‰∏≠...
                </>
              ) : (
                '„Ç§„Éô„É≥„Éà‰ΩúÊàê & DiscordÈÄöÁü•'
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* DiscordË®≠ÂÆö„ÉÄ„Ç§„Ç¢„É≠„Ç∞ Removed */}
      {/* <Dialog open={showDiscordSettings} onOpenChange={setShowDiscordSettings}> ... </Dialog> */}
    </div>
  );
}
